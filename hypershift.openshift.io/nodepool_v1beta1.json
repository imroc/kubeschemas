{
  "description": "NodePool is a scalable set of worker nodes attached to a HostedCluster.\nNodePool machine architectures are uniform within a given pool, and are\nindependent of the control planeâ€™s underlying machine architecture.",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "enum": [
        "hypershift.openshift.io/v1beta1"
      ],
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "enum": [
        "NodePool"
      ],
      "type": "string"
    },
    "metadata": {
      "allOf": [
        {
          "$ref": "../meta.apis.pkg.apimachinery.k8s.io/objectmeta_v1.json"
        }
      ],
      "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata"
    },
    "spec": {
      "description": "Spec is the desired behavior of the NodePool.",
      "properties": {
        "arch": {
          "default": "amd64",
          "description": "arch is the preferred processor architecture for the NodePool. Different platforms might have different supported architectures.\n\thttps://github.com/kubernetes/kubernetes/issues/108768#issuecomment-1253912215",
          "enum": [
            "arm64",
            "amd64",
            "ppc64le"
          ],
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "Arch is immutable",
              "rule": "self == oldSelf"
            }
          ]
        },
        "autoScaling": {
          "description": "autoscaling specifies auto-scaling behavior for the NodePool.\nautoscaling is mutually exclusive with replicas. If replicas is set, this field must be omitted.",
          "properties": {
            "max": {
              "description": "Max is the maximum number of nodes allowed in the pool. Must be \u003e= 1 and \u003e= Min.",
              "format": "int32",
              "minimum": 1,
              "type": "integer"
            },
            "min": {
              "description": "Min is the minimum number of nodes to maintain in the pool. Must be \u003e= 1 and \u003c= .Max.",
              "format": "int32",
              "minimum": 1,
              "type": "integer"
            }
          },
          "required": [
            "max",
            "min"
          ],
          "type": "object",
          "x-kubernetes-validations": [
            {
              "message": "max must be equal or greater than min",
              "rule": "self.max \u003e= self.min"
            }
          ]
        },
        "clusterName": {
          "description": "clusterName is the name of the HostedCluster this NodePool belongs to.\nIf a HostedCluster with this name doesn't exist, the controller will no-op until it exists.",
          "maxLength": 253,
          "minLength": 1,
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "ClusterName is immutable",
              "rule": "self == oldSelf"
            },
            {
              "message": "clusterName must consist of lowercase alphanumeric characters or '-', start and end with an alphanumeric character, and be between 1 and 253 characters",
              "rule": "self.matches('^[a-z0-9]([-a-z0-9]*[a-z0-9])?$')"
            }
          ]
        },
        "config": {
          "description": "config is a list of references to ConfigMaps containing serialized\nMachineConfig resources to be injected into the ignition configurations of\nnodes in the NodePool. The MachineConfig API schema is defined here:\n\nhttps://github.com/openshift/machine-config-operator/blob/18963e4f8fe66e8c513ca4b131620760a414997f/pkg/apis/machineconfiguration.openshift.io/v1/types.go#L185\n\nEach ConfigMap must have a single key named \"config\" whose value is the YML\nwith one or more serialized machineconfiguration.openshift.io resources:\n\n* KubeletConfig\n* ContainerRuntimeConfig\n* MachineConfig\n* ClusterImagePolicy\n* ImageContentSourcePolicy\n* ImageDigestMirrorSet\n\nThis is validated in the backend and signaled back via validMachineConfig condition.\nChanging this field will trigger a NodePool rollout.",
          "items": {
            "description": "LocalObjectReference contains enough information to let you locate the\nreferenced object inside the same namespace.",
            "properties": {
              "name": {
                "default": "",
                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                "type": "string"
              }
            },
            "type": "object",
            "x-kubernetes-map-type": "atomic"
          },
          "type": "array"
        },
        "management": {
          "description": "management specifies behavior for managing nodes in the pool, such as\nupgrade strategies and auto-repair behaviors.",
          "properties": {
            "autoRepair": {
              "default": false,
              "description": "autoRepair specifies whether health checks should be enabled for machines in the NodePool. The default is false.\nEnabling this feature will cause the controller to automatically delete unhealthy machines.\nThe unhealthy criteria is reserved for the controller implementation and subject to change.\nBut generally it's determined by checking the Node ready condition is true and a timeout that might vary depending on the platform provider.\nAutoRepair will no-op when more than 2 Nodes are unhealthy at the same time. Giving time for the cluster to stabilize or to the user to manually intervene.",
              "type": "boolean"
            },
            "inPlace": {
              "description": "inPlace is the configuration for in-place upgrades.",
              "properties": {
                "maxUnavailable": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "description": "maxUnavailable is the maximum number of nodes that can be unavailable\nduring the update.\n\nValue can be an absolute number (ex: 5) or a percentage of desired nodes\n(ex: 10%).\n\nAbsolute number is calculated from percentage by rounding down.\n\nDefaults to 1.\n\nExample: when this is set to 30%, a max of 30% of the nodes can be made\nunschedulable/unavailable immediately when the update starts. Once a set\nof nodes is updated, more nodes can be made unschedulable for update,\nensuring that the total number of nodes schedulable at all times during\nthe update is at least 70% of desired nodes.",
                  "x-kubernetes-int-or-string": true
                }
              },
              "type": "object"
            },
            "replace": {
              "default": {
                "rollingUpdate": {
                  "maxSurge": 1,
                  "maxUnavailable": 0
                },
                "strategy": "RollingUpdate"
              },
              "description": "replace is the configuration for rolling upgrades.\nIt defaults to a RollingUpdate strategy with maxSurge of 1 and maxUnavailable of 0.",
              "properties": {
                "rollingUpdate": {
                  "description": "rollingUpdate specifies a rolling update strategy which upgrades nodes by\ncreating new nodes and deleting the old ones.",
                  "properties": {
                    "maxSurge": {
                      "anyOf": [
                        {
                          "type": "integer"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "description": "maxSurge is the maximum number of nodes that can be provisioned above the\ndesired number of nodes.\n\nValue can be an absolute number (ex: 5) or a percentage of desired nodes\n(ex: 10%).\n\nAbsolute number is calculated from percentage by rounding up.\n\nThis can not be 0 if MaxUnavailable is 0.\n\nDefaults to 1.\n\nExample: when this is set to 30%, new nodes can be provisioned immediately\nwhen the rolling update starts, such that the total number of old and new\nnodes do not exceed 130% of desired nodes. Once old nodes have been\ndeleted, new nodes can be provisioned, ensuring that total number of nodes\nrunning at any time during the update is at most 130% of desired nodes.",
                      "x-kubernetes-int-or-string": true
                    },
                    "maxUnavailable": {
                      "anyOf": [
                        {
                          "type": "integer"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "description": "maxUnavailable is the maximum number of nodes that can be unavailable\nduring the update.\n\nValue can be an absolute number (ex: 5) or a percentage of desired nodes\n(ex: 10%).\n\nAbsolute number is calculated from percentage by rounding down.\n\nThis can not be 0 if MaxSurge is 0.\n\nDefaults to 0.\n\nExample: when this is set to 30%, old nodes can be deleted down to 70% of\ndesired nodes immediately when the rolling update starts. Once new nodes\nare ready, more old nodes be deleted, followed by provisioning new nodes,\nensuring that the total number of nodes available at all times during the\nupdate is at least 70% of desired nodes.",
                      "x-kubernetes-int-or-string": true
                    }
                  },
                  "type": "object"
                },
                "strategy": {
                  "description": "strategy is the node replacement strategy for nodes in the pool.\nIn can be either \"RollingUpdate\" or \"OnDelete\". RollingUpdate will rollout Nodes honoring maxSurge and maxUnavailable.\nOnDelete provide more granular control and will replace nodes as the old ones are manually deleted.",
                  "enum": [
                    "RollingUpdate",
                    "OnDelete"
                  ],
                  "type": "string"
                }
              },
              "type": "object",
              "x-kubernetes-validations": [
                {
                  "message": "The 'rollingUpdate' field can only be set when 'strategy' is 'RollingUpdate'",
                  "rule": "!has(self.rollingUpdate) || self.strategy == 'RollingUpdate'"
                }
              ]
            },
            "upgradeType": {
              "description": "upgradeType specifies the type of strategy for handling upgrades.\nThis can be either \"Replace\" or \"InPlace\".\n\"Replace\" will update Nodes by recreating the underlying instances.\n\"InPlace\" will update Nodes by applying changes to the existing instances. This might or might not result in a reboot.",
              "enum": [
                "Replace",
                "InPlace"
              ],
              "type": "string",
              "x-kubernetes-validations": [
                {
                  "message": "UpgradeType is immutable",
                  "rule": "self == oldSelf"
                }
              ]
            }
          },
          "required": [
            "upgradeType"
          ],
          "type": "object",
          "x-kubernetes-validations": [
            {
              "message": "The 'inPlace' field can only be set when 'upgradeType' is 'InPlace'",
              "rule": "!has(self.inPlace) || self.upgradeType == 'InPlace'"
            }
          ]
        },
        "nodeDrainTimeout": {
          "description": "nodeDrainTimeout is the maximum amount of time that the controller will spend on retrying to drain a node until it succeeds.\nThe default value is 0, meaning that the node can retry drain without any time limitations.\nChanging this field propagate inplace into existing Nodes.",
          "type": "string"
        },
        "nodeLabels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "nodeLabels propagates a list of labels to Nodes, only once on creation.\nValid values are those in https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set",
          "type": "object"
        },
        "nodeVolumeDetachTimeout": {
          "description": "nodeVolumeDetachTimeout is the maximum amount of time that the controller will spend on detaching volumes from a node.\nThe default value is 0, meaning that the volumes will be detached from the node without any time limitations.\nAfter the timeout, any remaining attached volumes will be ignored and the removal of the machine will continue.\nChanging this field propagate inplace into existing Nodes.",
          "type": "string"
        },
        "pausedUntil": {
          "description": "pausedUntil is a field that can be used to pause reconciliation on the NodePool controller. Resulting in any change to the NodePool being ignored.\nEither a date can be provided in RFC3339 format or a boolean as in 'true', 'false', 'True', 'False'. If a date is\nprovided: reconciliation is paused on the resource until that date. If the boolean true is\nprovided: reconciliation is paused on the resource until the field is removed.",
          "maxLength": 35,
          "minLength": 1,
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "PausedUntil must be a date in RFC3339 format or 'True', 'true', 'False' or 'false'",
              "rule": "self.matches('^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}.*$') || self in ['true', 'false', 'True', 'False']"
            }
          ]
        },
        "platform": {
          "description": "platform specifies the underlying infrastructure provider for the NodePool\nand is used to configure platform specific behavior.",
          "properties": {
            "agent": {
              "description": "Agent specifies the configuration used when using Agent platform.",
              "properties": {
                "agentLabelSelector": {
                  "description": "AgentLabelSelector contains labels that must be set on an Agent in order to\nbe selected for a Machine.",
                  "properties": {
                    "matchExpressions": {
                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                      "items": {
                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                        "properties": {
                          "key": {
                            "description": "key is the label key that the selector applies to.",
                            "type": "string"
                          },
                          "operator": {
                            "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                            "type": "string"
                          },
                          "values": {
                            "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                            "items": {
                              "type": "string"
                            },
                            "type": "array",
                            "x-kubernetes-list-type": "atomic"
                          }
                        },
                        "required": [
                          "key",
                          "operator"
                        ],
                        "type": "object"
                      },
                      "type": "array",
                      "x-kubernetes-list-type": "atomic"
                    },
                    "matchLabels": {
                      "additionalProperties": {
                        "type": "string"
                      },
                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                      "type": "object"
                    }
                  },
                  "type": "object",
                  "x-kubernetes-map-type": "atomic"
                }
              },
              "type": "object"
            },
            "aws": {
              "description": "AWS specifies the configuration used when operating on AWS.",
              "properties": {
                "ami": {
                  "description": "AMI is the image id to use for node instances. If unspecified, the default\nis chosen based on the NodePool release payload image.",
                  "type": "string"
                },
                "instanceProfile": {
                  "description": "InstanceProfile is the AWS EC2 instance profile, which is a container for an IAM role that the EC2 instance uses.",
                  "type": "string"
                },
                "instanceType": {
                  "description": "InstanceType is an ec2 instance type for node instances (e.g. m5.large).",
                  "type": "string"
                },
                "placement": {
                  "description": "placement specifies the placement options for the EC2 instances.",
                  "properties": {
                    "tenancy": {
                      "description": "Tenancy indicates if instance should run on shared or single-tenant hardware.\n\nPossible values:\ndefault: NodePool instances run on shared hardware.\ndedicated: Each NodePool instance runs on single-tenant hardware.\nhost: NodePool instances run on user's pre-allocated dedicated hosts.",
                      "enum": [
                        "default",
                        "dedicated",
                        "host"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "resourceTags": {
                  "description": "ResourceTags is an optional list of additional tags to apply to AWS node\ninstances.\n\nThese will be merged with HostedCluster scoped tags, and HostedCluster tags\ntake precedence in case of conflicts.\n\nSee https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html for\ninformation on tagging AWS resources. AWS supports a maximum of 50 tags per\nresource. OpenShift reserves 25 tags for its use, leaving 25 tags available\nfor the user.",
                  "items": {
                    "description": "AWSResourceTag is a tag to apply to AWS resources created for the cluster.",
                    "properties": {
                      "key": {
                        "description": "Key is the key of the tag.",
                        "maxLength": 128,
                        "minLength": 1,
                        "pattern": "^[0-9A-Za-z_.:/=+-@]+$",
                        "type": "string"
                      },
                      "value": {
                        "description": "Value is the value of the tag.\n\nSome AWS service do not support empty values. Since tags are added to\nresources in many services, the length of the tag value must meet the\nrequirements of all services.",
                        "maxLength": 256,
                        "minLength": 1,
                        "pattern": "^[0-9A-Za-z_.:/=+-@]+$",
                        "type": "string"
                      }
                    },
                    "required": [
                      "key",
                      "value"
                    ],
                    "type": "object"
                  },
                  "maxItems": 25,
                  "type": "array"
                },
                "rootVolume": {
                  "description": "RootVolume specifies configuration for the root volume of node instances.",
                  "properties": {
                    "encrypted": {
                      "description": "Encrypted is whether the volume should be encrypted or not.",
                      "type": "boolean",
                      "x-kubernetes-validations": [
                        {
                          "message": "Encrypted is immutable",
                          "rule": "self == oldSelf"
                        }
                      ]
                    },
                    "encryptionKey": {
                      "description": "EncryptionKey is the KMS key to use to encrypt the volume. Can be either a KMS key ID or ARN.\nIf Encrypted is set and this is omitted, the default AWS key will be used.\nThe key must already exist and be accessible by the controller.",
                      "type": "string"
                    },
                    "iops": {
                      "description": "IOPS is the number of IOPS requested for the disk. This is only valid\nfor type io1.",
                      "format": "int64",
                      "type": "integer"
                    },
                    "size": {
                      "description": "Size specifies size (in Gi) of the storage device.\n\nMust be greater than the image snapshot size or 8 (whichever is greater).",
                      "format": "int64",
                      "minimum": 8,
                      "type": "integer"
                    },
                    "type": {
                      "description": "Type is the type of the volume.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "size",
                    "type"
                  ],
                  "type": "object"
                },
                "securityGroups": {
                  "description": "SecurityGroups is an optional set of security groups to associate with node\ninstances.",
                  "items": {
                    "description": "AWSResourceReference is a reference to a specific AWS resource by ID or filters.\nOnly one of ID or Filters may be specified. Specifying more than one will result in\na validation error.",
                    "properties": {
                      "filters": {
                        "description": "Filters is a set of key/value pairs used to identify a resource\nThey are applied according to the rules defined by the AWS API:\nhttps://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Filtering.html",
                        "items": {
                          "description": "Filter is a filter used to identify an AWS resource",
                          "properties": {
                            "name": {
                              "description": "Name of the filter. Filter names are case-sensitive.",
                              "type": "string"
                            },
                            "values": {
                              "description": "Values includes one or more filter values. Filter values are case-sensitive.",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          },
                          "required": [
                            "name",
                            "values"
                          ],
                          "type": "object"
                        },
                        "type": "array"
                      },
                      "id": {
                        "description": "ID of resource",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "type": "array"
                },
                "subnet": {
                  "description": "Subnet is the subnet to use for node instances.",
                  "properties": {
                    "filters": {
                      "description": "Filters is a set of key/value pairs used to identify a resource\nThey are applied according to the rules defined by the AWS API:\nhttps://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Filtering.html",
                      "items": {
                        "description": "Filter is a filter used to identify an AWS resource",
                        "properties": {
                          "name": {
                            "description": "Name of the filter. Filter names are case-sensitive.",
                            "type": "string"
                          },
                          "values": {
                            "description": "Values includes one or more filter values. Filter values are case-sensitive.",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          }
                        },
                        "required": [
                          "name",
                          "values"
                        ],
                        "type": "object"
                      },
                      "type": "array"
                    },
                    "id": {
                      "description": "ID of resource",
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "x-kubernetes-validations": [
                    {
                      "message": "subnet is invalid, a valid subnet id or filters must be set, but not both",
                      "rule": "has(self.id) \u0026\u0026 self.id.startsWith('subnet-') ? !has(self.filters) : size(self.filters) \u003e 0"
                    }
                  ]
                }
              },
              "required": [
                "instanceType",
                "subnet"
              ],
              "type": "object"
            },
            "azure": {
              "description": "AzureNodePoolPlatform is the platform specific configuration for an Azure node pool.",
              "properties": {
                "availabilityZone": {
                  "description": "availabilityZone is the failure domain identifier where the VM should be attached to. This must not be specified\nfor clusters in a location that does not support AvailabilityZone because it would cause a failure from Azure API.",
                  "type": "string"
                },
                "diagnostics": {
                  "description": "diagnostics specifies the diagnostics settings for a virtual machine.\nIf not specified, then Boot diagnostics will be disabled.",
                  "properties": {
                    "storageAccountType": {
                      "allOf": [
                        {
                          "enum": [
                            "Managed",
                            "UserManaged",
                            "Disabled"
                          ]
                        },
                        {
                          "enum": [
                            "Managed",
                            "UserManaged",
                            "Disabled"
                          ]
                        }
                      ],
                      "default": "Disabled",
                      "description": "storageAccountType determines if the storage account for storing the diagnostics data\nshould be disabled (Disabled), provisioned by Azure (Managed) or by the user (UserManaged).",
                      "type": "string"
                    },
                    "userManaged": {
                      "description": "userManaged specifies the diagnostics settings for a virtual machine when the storage account is managed by the user.",
                      "properties": {
                        "storageAccountURI": {
                          "description": "storageAccountURI is the URI of the user-managed storage account.\nThe URI typically will be `https://\u003cmystorageaccountname\u003e.blob.core.windows.net/`\nbut may differ if you are using Azure DNS zone endpoints.\nYou can find the correct endpoint by looking for the Blob Primary Endpoint in the\nendpoints tab in the Azure console or with the CLI by issuing\n`az storage account list --query='[].{name: name, \"resource group\": resourceGroup, \"blob endpoint\": primaryEndpoints.blob}'`.",
                          "maxLength": 1024,
                          "type": "string",
                          "x-kubernetes-validations": [
                            {
                              "message": "storageAccountURI must be a valid HTTPS URL",
                              "rule": "isURL(self) \u0026\u0026 url(self).getScheme() == 'https'"
                            }
                          ]
                        }
                      },
                      "required": [
                        "storageAccountURI"
                      ],
                      "type": "object"
                    }
                  },
                  "type": "object",
                  "x-kubernetes-validations": [
                    {
                      "message": "userManaged is required when storageAccountType is UserManaged, and forbidden otherwise",
                      "rule": "self.storageAccountType == 'UserManaged' ? has(self.userManaged) : !has(self.userManaged)"
                    }
                  ]
                },
                "encryptionAtHost": {
                  "default": "Enabled",
                  "description": "encryptionAtHost enables encryption at host on virtual machines. According to Microsoft documentation, this\nmeans data stored on the VM host is encrypted at rest and flows encrypted to the Storage service. See\nhttps://learn.microsoft.com/en-us/azure/virtual-machines/disks-enable-host-based-encryption-portal?tabs=azure-powershell\nfor more information.",
                  "enum": [
                    "Enabled",
                    "Disabled"
                  ],
                  "type": "string"
                },
                "image": {
                  "description": "image is used to configure the VM boot image. If unset, the default image at the location below will be used and\nis expected to exist: subscription/\u003csubscriptionID\u003e/resourceGroups/\u003cresourceGroupName\u003e/providers/Microsoft.Compute/images/rhcos.x86_64.vhd.\nThe \u003csubscriptionID\u003e and the \u003cresourceGroupName\u003e are expected to be the same resource group documented in the\nHosted Cluster specification respectively, HostedCluster.Spec.Platform.Azure.SubscriptionID and\nHostedCluster.Spec.Platform.Azure.ResourceGroupName.",
                  "properties": {
                    "azureMarketplace": {
                      "description": "azureMarketplace contains the Azure Marketplace image info to use to boot the Azure VMs from.",
                      "properties": {
                        "offer": {
                          "description": "offer specifies the name of a group of related images created by the publisher.",
                          "minLength": 1,
                          "type": "string"
                        },
                        "publisher": {
                          "description": "publisher is the name of the organization that created the image.\nIt must be between 3 and 50 characters in length, and consist of only lowercase letters, numbers, and hyphens (-) and underscores (_).\nIt must start with a lowercase letter or a number.",
                          "maxLength": 50,
                          "minLength": 3,
                          "pattern": "^[a-z0-9][a-z0-9-_]{2,49}$",
                          "type": "string"
                        },
                        "sku": {
                          "description": "sku specifies an instance of an offer, such as a major release of a distribution.\nFor example, 22_04-lts-gen2, 8-lvm-gen2.\nThe value must consist only of lowercase letters, numbers, and hyphens (-) and underscores (_).",
                          "minLength": 1,
                          "pattern": "^[a-z0-9-_]+$",
                          "type": "string"
                        },
                        "version": {
                          "description": "version specifies the version of an image sku. The allowed formats are Major.Minor.Build or 'latest'. Major,\nMinor, and Build are decimal numbers, e.g. '1.2.0'. Specify 'latest' to use the latest version of an image available at\ndeployment time. Even if you use 'latest', the VM image will not automatically update after deploy time even if a\nnew version becomes available.",
                          "maxLength": 32,
                          "minLength": 1,
                          "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+$|^latest$",
                          "type": "string"
                        }
                      },
                      "required": [
                        "offer",
                        "publisher",
                        "sku",
                        "version"
                      ],
                      "type": "object"
                    },
                    "imageID": {
                      "description": "imageID is the Azure resource ID of a VHD image to use to boot the Azure VMs from.",
                      "type": "string"
                    },
                    "type": {
                      "description": "type is the type of image data that will be provided to the Azure VM.\nValid values are \"ImageID\" and \"AzureMarketplace\".\nImageID means is used for legacy managed VM images. This is where the user uploads a VM image directly to their resource group.\nAzureMarketplace means the VM will boot from an Azure Marketplace image.\nMarketplace images are preconfigured and published by the OS vendors and may include preconfigured software for the VM.",
                      "enum": [
                        "ImageID",
                        "AzureMarketplace"
                      ],
                      "type": "string"
                    }
                  },
                  "required": [
                    "type"
                  ],
                  "type": "object",
                  "x-kubernetes-validations": [
                    {
                      "message": "imageID is required when type is ImageID, and forbidden otherwise",
                      "rule": "has(self.type) \u0026\u0026 self.type == 'ImageID' ?  has(self.imageID) : !has(self.imageID)"
                    },
                    {
                      "message": "azureMarketplace is required when type is RequiredMember, and forbidden otherwise",
                      "rule": "has(self.type) \u0026\u0026 self.type == 'AzureMarketplace' ?  has(self.azureMarketplace) : !has(self.azureMarketplace)"
                    }
                  ]
                },
                "machineIdentityID": {
                  "description": "machineIdentityID is a user-assigned identity assigned to the VMs used to authenticate with Azure services. The\nidentify is expected to exist under the same resource group as HostedCluster.Spec.Platform.Azure.ResourceGroupName. This\nuser assigned identity is expected to have the Contributor role assigned to it and scoped to the resource group\nunder HostedCluster.Spec.Platform.Azure.ResourceGroupName.\n\nIf this field is not supplied, the Service Principal credentials will be written to a file on the disk of each VM\nin order to be accessible by the cloud provider; the aforementioned credentials provided are the same ones as\nHostedCluster.Spec.Platform.Azure.Credentials. However, this is less secure than using a managed identity.\n",
                  "type": "string"
                },
                "osDisk": {
                  "description": "osDisk provides configuration for the OS disk for the nodepool.\nThis can be used to configure the size, storage account type, encryption options and whether the disk is persistent or ephemeral.\nWhen not provided, the platform will choose reasonable defaults which are subject to change over time.\nReview the fields within the osDisk for more details.",
                  "properties": {
                    "diskStorageAccountType": {
                      "description": "diskStorageAccountType is the disk storage account type to use.\nValid values are Premium_LRS, PremiumV2_LRS, Standard_LRS, StandardSSD_LRS, UltraSSD_LRS.\nNote that Standard means a HDD.\nThe disk performance is tied to the disk type, please refer to the Azure documentation for further details\nhttps://docs.microsoft.com/en-us/azure/virtual-machines/disks-types#disk-type-comparison.\nWhen omitted this means no opinion and the platform is left to choose a reasonable default, which is subject to change over time.\nThe current default is Premium SSD LRS.",
                      "enum": [
                        "Premium_LRS",
                        "PremiumV2_LRS",
                        "Standard_LRS",
                        "StandardSSD_LRS",
                        "UltraSSD_LRS"
                      ],
                      "type": "string"
                    },
                    "encryptionSetID": {
                      "description": "encryptionSetID is the ID of the DiskEncryptionSet resource to use to encrypt the OS disks for the VMs.\nConfiguring a DiskEncyptionSet allows greater control over the encryption of the VM OS disk at rest.\nCan be used with either platform (Azure) managed, or customer managed encryption keys.\nThis needs to exist in the same subscription id listed in the Hosted Cluster, HostedCluster.Spec.Platform.Azure.SubscriptionID.\nDiskEncryptionSetID should also exist in a resource group under the same subscription id and the same location\nlisted in the Hosted Cluster, HostedCluster.Spec.Platform.Azure.Location.\nThe encryptionSetID should be in the format `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Copmute/diskEncryptionSets/{resourceName}`.\nThe subscriptionId in the encryptionSetID must be a valid UUID. It should be 5 groups of hyphen separated hexadecimal characters in the form 8-4-4-4-12.\nThe resourceGroupName should be between 1 and 90 characters, consisting only of alphanumeric characters, hyphens, underscores, periods and parenthesis and must not end with a period (.) character.\nThe resourceName should be between 1 and 80 characters, consisting only of alphanumeric characters, hyphens and underscores.",
                      "maxLength": 285,
                      "type": "string",
                      "x-kubernetes-validations": [
                        {
                          "message": "encryptionSetID must be in the format `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Copmute/diskEncryptionSets/{resourceName}`",
                          "rule": "size(self.split('/')) == 9 \u0026\u0026 self.matches('^/subscriptions/.*/resourceGroups/.*/providers/Microsoft.Compute/diskEncryptionSets/.*$')"
                        },
                        {
                          "message": "The resourceGroupName should be between 1 and 90 characters, consisting only of alphanumeric characters, hyphens, underscores, periods and parenthesis",
                          "rule": "self.split('/')[4].matches('[a-zA-Z0-9-_\\\\(\\\\)\\\\.]{1,90}')"
                        },
                        {
                          "message": "the resourceGroupName in the encryptionSetID must not end with a period (.) character",
                          "rule": "!self.split('/')[4].endsWith('.')"
                        },
                        {
                          "message": "The resourceName should be between 1 and 80 characters, consisting only of alphanumeric characters, hyphens and underscores",
                          "rule": "self.split('/')[8].matches('[a-zA-Z0-9-_]{1,80}')"
                        }
                      ]
                    },
                    "persistence": {
                      "description": "persistence determines whether the OS disk should be persisted beyond the life of the VM.\nValid values are Persistent and Ephemeral.\nWhen set to Ephmeral, the OS disk will not be persisted to Azure storage and implies restrictions to the VM size and caching type.\nFull details can be found in the Azure documentation https://learn.microsoft.com/en-us/azure/virtual-machines/ephemeral-os-disks.\nEphmeral disks are primarily used for stateless applications, provide lower latency than Persistent disks and also incur no storage costs.\nWhen not set, this means no opinion and the platform is left to choose a reasonable default, which is subject to change over time.",
                      "enum": [
                        "Persistent",
                        "Ephemeral"
                      ],
                      "type": "string"
                    },
                    "sizeGiB": {
                      "description": "SizeGiB is the size in GiB (1024^3 bytes) to assign to the OS disk.\nThis should be between 16 and 65,536 when using the UltraSSD_LRS storage account type and between 16 and 32,767 when using any other storage account type.\nWhen not set, this means no opinion and the platform is left to choose a reasonable default, which is subject to change over time.\nThe current default is 30.",
                      "format": "int32",
                      "maximum": 65536,
                      "minimum": 16,
                      "type": "integer"
                    }
                  },
                  "type": "object",
                  "x-kubernetes-validations": [
                    {
                      "message": "When not using diskStorageAccountType UltraSSD_LRS, the SizeGB value must be less than or equal to 32,767",
                      "rule": "!has(self.diskStorageAccountType) || self.diskStorageAccountType != 'UltraSSD_LRS' || self.sizeGiB \u003c= 32767"
                    }
                  ]
                },
                "subnetID": {
                  "description": "subnetID is the subnet ID of an existing subnet where the nodes in the nodepool will be created. This can be a\ndifferent subnet than the one listed in the HostedCluster, HostedCluster.Spec.Platform.Azure.SubnetID, but must\nexist in the same network, HostedCluster.Spec.Platform.Azure.VnetID, and must exist under the same subscription ID,\nHostedCluster.Spec.Platform.Azure.SubscriptionID.\nsubnetID is immutable once set.\nThe subnetID should be in the format `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}`.\nThe subscriptionId in the encryptionSetID must be a valid UUID. It should be 5 groups of hyphen separated hexadecimal characters in the form 8-4-4-4-12.\nThe resourceGroupName should be between 1 and 90 characters, consisting only of alphanumeric characters, hyphens, underscores, periods and parenthesis and must not end with a period (.) character.\nThe vnetName should be between 2 and 64 characters, consisting only of alphanumeric characters, hyphens, underscores and periods and must not end with either a period (.) or hyphen (-) character.\nThe subnetName should be between 1 and 80 characters, consisting only of alphanumeric characters, hyphens and underscores and must start with an alphanumeric character and must not end with a period (.) or hyphen (-) character.",
                  "maxLength": 355,
                  "minLength": 1,
                  "type": "string",
                  "x-kubernetes-validations": [
                    {
                      "message": "encryptionSetID must be in the format `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}`",
                      "rule": "size(self.split('/')) == 11 \u0026\u0026 self.matches('^/subscriptions/.*/resourceGroups/.*/providers/Microsoft.Network/virtualNetworks/.*/subnets/.*$')"
                    },
                    {
                      "message": "The resourceGroupName should be between 1 and 90 characters, consisting only of alphanumeric characters, hyphens, underscores, periods and parenthesis",
                      "rule": "self.split('/')[4].matches('[a-zA-Z0-9-_\\\\(\\\\)\\\\.]{1,90}')"
                    },
                    {
                      "message": "the resourceGroupName in the subnetID must not end with a period (.) character",
                      "rule": "!self.split('/')[4].endsWith('.')"
                    },
                    {
                      "message": "The vnetName should be between 2 and 64 characters, consisting only of alphanumeric characters, hyphens, underscores and periods",
                      "rule": "self.split('/')[8].matches('[a-zA-Z0-9-_\\\\.]{2,64}')"
                    },
                    {
                      "message": "the vnetName in the subnetID must not end with either a period (.) or hyphen (-) character",
                      "rule": "!self.split('/')[8].endsWith('.') \u0026\u0026 !self.split('/')[8].endsWith('-')"
                    },
                    {
                      "message": "The subnetName should be between 1 and 80 characters, consisting only of alphanumeric characters, hyphens and underscores and must start with an alphanumeric character",
                      "rule": "self.split('/')[10].matches('[a-zA-Z0-9][a-zA-Z0-9-_\\\\.]{0,79}')"
                    },
                    {
                      "message": "the subnetName in the subnetID must not end with a period (.) or hyphen (-) character",
                      "rule": "!self.split('/')[10].endsWith('.') \u0026\u0026 !self.split('/')[10].endsWith('-')"
                    },
                    {
                      "message": "SubnetID is immutable",
                      "rule": "self == oldSelf"
                    }
                  ]
                },
                "vmSize": {
                  "description": "vmSize is the Azure VM instance type to use for the nodes being created in the nodepool.\nThe size naming convention is documented here https://learn.microsoft.com/en-us/azure/virtual-machines/vm-naming-conventions.\nSize names should start with a Family name, which is represented by one of more capital letters, and then be followed by the CPU count.\nThis is followed by 0 or more additional features, represented by a, b, d, i, l, m, p, t, s, C, and NP, refer to the Azure documentation for an explanation of these features.\nOptionally an accelerator such as a GPU can be added, prefixed by an underscore, for example A100, H100 or MI300X.\nThe size may also be versioned, in which case it should be suffixed with _v\u003cversion\u003e where the version is a number.\nFor example, \"D32ads_v5\" would be a suitable general purpose VM size, or \"ND96_MI300X_v5\" would represent a GPU accelerated VM.",
                  "pattern": "^(Standard_|Basic_)?[A-Z]+[0-9]+(-[0-9]+)?[abdilmptsCNP]*(_[A-Z]*[0-9]+[A-Z]*)?(_v[0-9]+)?$",
                  "type": "string"
                }
              },
              "required": [
                "image",
                "osDisk",
                "subnetID",
                "vmSize"
              ],
              "type": "object"
            },
            "ibmcloud": {
              "description": "IBMCloud defines IBMCloud specific settings for components",
              "properties": {
                "providerType": {
                  "description": "ProviderType is a specific supported infrastructure provider within IBM Cloud.",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "kubevirt": {
              "description": "Kubevirt specifies the configuration used when operating on KubeVirt platform.",
              "properties": {
                "additionalNetworks": {
                  "description": "AdditionalNetworks specify the extra networks attached to the nodes",
                  "items": {
                    "description": "KubevirtNetwork specifies the configuration for a virtual machine\nnetwork interface",
                    "properties": {
                      "name": {
                        "description": "Name specify the network attached to the nodes\nit is a value with the format \"[namespace]/[name]\" to reference the\nmultus network attachment definition",
                        "type": "string"
                      }
                    },
                    "required": [
                      "name"
                    ],
                    "type": "object"
                  },
                  "type": "array"
                },
                "attachDefaultNetwork": {
                  "default": true,
                  "description": "AttachDefaultNetwork specify if the default pod network should be attached to the nodes\nthis can only be set to false if AdditionalNetworks are configured",
                  "type": "boolean"
                },
                "compute": {
                  "default": {
                    "cores": 2,
                    "memory": "8Gi"
                  },
                  "description": "Compute contains values representing the virtual hardware requested for the VM",
                  "properties": {
                    "cores": {
                      "default": 2,
                      "description": "Cores represents how many cores the guest VM should have",
                      "format": "int32",
                      "type": "integer"
                    },
                    "memory": {
                      "anyOf": [
                        {
                          "type": "integer"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "default": "8Gi",
                      "description": "Memory represents how much guest memory the VM should have",
                      "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                      "x-kubernetes-int-or-string": true
                    },
                    "qosClass": {
                      "default": "Burstable",
                      "description": "QosClass If set to \"Guaranteed\", requests the scheduler to place the VirtualMachineInstance on a node with\nlimit memory and CPU, equal to be the requested values, to set the VMI as a Guaranteed QoS Class;\nSee here for more details:\nhttps://kubevirt.io/user-guide/operations/node_overcommit/#requesting-the-right-qos-class-for-virtualmachineinstances",
                      "enum": [
                        "Burstable",
                        "Guaranteed"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "hostDevices": {
                  "description": "KubevirtHostDevices specifies the host devices (e.g. GPU devices) to be passed\nfrom the management cluster, to the nodepool nodes",
                  "items": {
                    "properties": {
                      "count": {
                        "default": 1,
                        "description": "Count is the number of instances the specified host device will be attached to each of the\nNodePool's nodes. Default is 1.",
                        "minimum": 1,
                        "type": "integer"
                      },
                      "deviceName": {
                        "description": "DeviceName is the name of the host device that is desired to be utilized in the HostedCluster's NodePool\nThe device can be any supported PCI device, including GPU, either as a passthrough or a vGPU slice.",
                        "type": "string"
                      }
                    },
                    "required": [
                      "deviceName"
                    ],
                    "type": "object"
                  },
                  "type": "array"
                },
                "networkInterfaceMultiqueue": {
                  "default": "Enable",
                  "description": "NetworkInterfaceMultiQueue If set to \"Enable\", virtual network interfaces configured with a virtio bus will also\nenable the vhost multiqueue feature for network devices. The number of queues created depends on additional\nfactors of the VirtualMachineInstance, like the number of guest CPUs.",
                  "enum": [
                    "Enable",
                    "Disable"
                  ],
                  "type": "string"
                },
                "nodeSelector": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "description": "NodeSelector is a selector which must be true for the kubevirt VirtualMachine to fit on a node.\nSelector which must match a node's labels for the VM to be scheduled on that node. More info:\nhttps://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
                  "type": "object"
                },
                "rootVolume": {
                  "default": {
                    "persistent": {
                      "size": "32Gi"
                    },
                    "type": "Persistent"
                  },
                  "description": "RootVolume represents values associated with the VM volume that will host rhcos",
                  "properties": {
                    "cacheStrategy": {
                      "description": "CacheStrategy defines the boot image caching strategy. Default - no caching",
                      "properties": {
                        "type": {
                          "default": "None",
                          "description": "Type is the type of the caching strategy",
                          "enum": [
                            "None",
                            "PVC"
                          ],
                          "type": "string"
                        }
                      },
                      "required": [
                        "type"
                      ],
                      "type": "object"
                    },
                    "diskImage": {
                      "description": "Image represents what rhcos image to use for the node pool",
                      "properties": {
                        "containerDiskImage": {
                          "description": "ContainerDiskImage is a string representing the container image that holds the root disk",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "persistent": {
                      "description": "Persistent volume type means the VM's storage is backed by a PVC\nVMs that use persistent volumes can survive disruption events like restart and eviction\nThis is the default type used when no storage type is defined.",
                      "properties": {
                        "accessModes": {
                          "description": "AccessModes is an array that contains the desired Access Modes the root volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes",
                          "items": {
                            "enum": [
                              "ReadWriteOnce",
                              "ReadWriteMany",
                              "ReadOnly",
                              "ReadWriteOncePod"
                            ],
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "size": {
                          "anyOf": [
                            {
                              "type": "integer"
                            },
                            {
                              "type": "string"
                            }
                          ],
                          "default": "32Gi",
                          "description": "Size is the size of the persistent storage volume",
                          "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                          "x-kubernetes-int-or-string": true
                        },
                        "storageClass": {
                          "description": "StorageClass is the storageClass used for the underlying PVC that hosts the volume",
                          "type": "string"
                        },
                        "volumeMode": {
                          "description": "VolumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.",
                          "enum": [
                            "Filesystem",
                            "Block"
                          ],
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "type": {
                      "default": "Persistent",
                      "description": "Type represents the type of storage to associate with the kubevirt VMs.",
                      "enum": [
                        "Persistent"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              },
              "required": [
                "rootVolume"
              ],
              "type": "object"
            },
            "powervs": {
              "description": "PowerVS specifies the configuration used when using IBMCloud PowerVS platform.",
              "properties": {
                "image": {
                  "description": "Image used for deploying the nodes. If unspecified, the default\nis chosen based on the NodePool release payload image.",
                  "properties": {
                    "id": {
                      "description": "ID of resource",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of resource",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "imageDeletePolicy": {
                  "default": "delete",
                  "description": "ImageDeletePolicy is policy for the image deletion.\n\ndelete: delete the image from the infrastructure.\nretain: delete the image from the openshift but retain in the infrastructure.\n\nThe default is delete",
                  "enum": [
                    "delete",
                    "retain"
                  ],
                  "type": "string"
                },
                "memoryGiB": {
                  "default": 32,
                  "description": "MemoryGiB is the size of a virtual machine's memory, in GiB.\nmaximum value for the MemoryGiB depends on the selected SystemType.\nwhen SystemType is set to e880 maximum MemoryGiB value is 7463 GiB.\nwhen SystemType is set to e980 maximum MemoryGiB value is 15307 GiB.\nwhen SystemType is set to s922 maximum MemoryGiB value is 942 GiB.\nThe minimum memory is 32 GiB.\n\nWhen omitted, this means the user has no opinion and the platform is left to choose a reasonable\ndefault. The current default is 32.",
                  "format": "int32",
                  "type": "integer"
                },
                "processorType": {
                  "default": "shared",
                  "description": "ProcessorType is the VM instance processor type.\nIt must be set to one of the following values: Dedicated, Capped or Shared.\n\nDedicated: resources are allocated for a specific client, The hypervisor makes a 1:1 binding of a partitionâ€™s processor to a physical processor core.\nShared: Shared among other clients.\nCapped: Shared, but resources do not expand beyond those that are requested, the amount of CPU time is Capped to the value specified for the entitlement.\n\nif the processorType is selected as Dedicated, then Processors value cannot be fractional.\nWhen omitted, this means that the user has no opinion and the platform is left to choose a\nreasonable default. The current default is shared.",
                  "enum": [
                    "dedicated",
                    "shared",
                    "capped"
                  ],
                  "type": "string"
                },
                "processors": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "default": "0.5",
                  "description": "Processors is the number of virtual processors in a virtual machine.\nwhen the processorType is selected as Dedicated the processors value cannot be fractional.\nmaximum value for the Processors depends on the selected SystemType.\nwhen SystemType is set to e880 or e980 maximum Processors value is 143.\nwhen SystemType is set to s922 maximum Processors value is 15.\nminimum value for Processors depends on the selected ProcessorType.\nwhen ProcessorType is set as Shared or Capped, The minimum processors is 0.5.\nwhen ProcessorType is set as Dedicated, The minimum processors is 1.\nWhen omitted, this means that the user has no opinion and the platform is left to choose a\nreasonable default. The default is set based on the selected ProcessorType.\nwhen ProcessorType selected as Dedicated, the default is set to 1.\nwhen ProcessorType selected as Shared or Capped, the default is set to 0.5.",
                  "x-kubernetes-int-or-string": true
                },
                "storageType": {
                  "default": "tier1",
                  "description": "StorageType for the image and nodes, this will be ignored if Image is specified.\nThe storage tiers in PowerVS are based on I/O operations per second (IOPS).\nIt means that the performance of your storage volumes is limited to the maximum number of IOPS based on volume size and storage tier.\nAlthough, the exact numbers might change over time, the Tier 3 storage is currently set to 3 IOPS/GB, and the Tier 1 storage is currently set to 10 IOPS/GB.\n\nThe default is tier1",
                  "enum": [
                    "tier1",
                    "tier3"
                  ],
                  "type": "string"
                },
                "systemType": {
                  "default": "s922",
                  "description": "SystemType is the System type used to host the instance.\nsystemType determines the number of cores and memory that is available.\nFew of the supported SystemTypes are s922,e880,e980.\ne880 systemType available only in Dallas Datacenters.\ne980 systemType available in Datacenters except Dallas and Washington.\nWhen omitted, this means that the user has no opinion and the platform is left to choose a\nreasonable default. The current default is s922 which is generally available.",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "type": {
              "description": "Type specifies the platform name.",
              "enum": [
                "AWS",
                "Azure",
                "IBMCloud",
                "KubeVirt",
                "Agent",
                "PowerVS",
                "None"
              ],
              "type": "string",
              "x-kubernetes-validations": [
                {
                  "message": "Type is immutable",
                  "rule": "self == oldSelf"
                }
              ]
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        },
        "release": {
          "description": "release specifies the OCP release used for the NodePool. This informs the\nignition configuration for machines which includes the kubelet version, as well as other platform specific\nmachine properties (e.g. an AMI on the AWS platform).\nIt's not supported to use a release in a NodePool which minor version skew against the Control Plane release is bigger than N-2. Although there's no enforcement that prevents this from happening.\nAttempting to use a release with a bigger skew might result in unpredictable behaviour.\nAttempting to use a release higher than the HosterCluster one will result in the NodePool being degraded and the ValidReleaseImage condition being false.\nAttempting to use a release lower than the current NodePool y-stream will result in the NodePool being degraded and the ValidReleaseImage condition being false.\nChanging this field will trigger a NodePool rollout.",
          "properties": {
            "image": {
              "description": "Image is the image pullspec of an OCP release payload image.\nSee https://quay.io/repository/openshift-release-dev/ocp-release?tab=tags for a list of available images.",
              "maxLength": 253,
              "minLength": 1,
              "type": "string",
              "x-kubernetes-validations": [
                {
                  "message": "Image must start with a word character (letters, digits, or underscores) and contain no white spaces",
                  "rule": "self.matches('^(\\\\w+\\\\S+)$')"
                }
              ]
            }
          },
          "required": [
            "image"
          ],
          "type": "object"
        },
        "replicas": {
          "description": "replicas is the desired number of nodes the pool should maintain. If unset, the controller default value is 0.\nreplicas is mutually exclusive with autoscaling. If autoscaling is configured, replicas must be omitted and autoscaling will control the NodePool size internally.",
          "format": "int32",
          "type": "integer"
        },
        "taints": {
          "description": "taints if specified, propagates a list of taints to Nodes, only once on creation.\nThese taints are additive to the ones applied by other controllers",
          "items": {
            "description": "taint is as v1 Core but without TimeAdded.\nhttps://github.com/kubernetes/kubernetes/blob/ed8cad1e80d096257921908a52ac69cf1f41a098/staging/src/k8s.io/api/core/v1/types.go#L3037-L3053\nValidation replicates the same validation as the upstream https://github.com/kubernetes/kubernetes/blob/9a2a7537f035969a68e432b4cc276dbce8ce1735/pkg/util/taints/taints.go#L273.\nSee also https://kubernetes.io/docs/concepts/overview/working-with-objects/names/.",
            "properties": {
              "effect": {
                "description": "effect is the effect of the taint on pods\nthat do not tolerate the taint.\nValid effects are NoSchedule, PreferNoSchedule and NoExecute.",
                "enum": [
                  "NoSchedule",
                  "PreferNoSchedule",
                  "NoExecute"
                ],
                "type": "string"
              },
              "key": {
                "description": "key is the taint key to be applied to a node.",
                "maxLength": 253,
                "minLength": 1,
                "type": "string",
                "x-kubernetes-validations": [
                  {
                    "message": "key must be a qualified name with an optional subdomain prefix e.g. example.com/MyName",
                    "rule": "self.matches('^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\\\/)?[A-Za-z0-9]([-A-Za-z0-9_.]{0,61}[A-Za-z0-9])?$')"
                  }
                ]
              },
              "value": {
                "description": "value is the taint value corresponding to the taint key.",
                "maxLength": 253,
                "type": "string",
                "x-kubernetes-validations": [
                  {
                    "message": "Value must start and end with alphanumeric characters and can only contain '-', '_', '.' in the middle",
                    "rule": "self.matches('^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$')"
                  }
                ]
              }
            },
            "required": [
              "effect",
              "key"
            ],
            "type": "object"
          },
          "maxItems": 50,
          "type": "array"
        },
        "tuningConfig": {
          "description": "tuningConfig is a list of references to ConfigMaps containing serialized\nTuned or PerformanceProfile resources to define the tuning configuration to be applied to\nnodes in the NodePool. The Tuned API is defined here:\n\nhttps://github.com/openshift/cluster-node-tuning-operator/blob/2c76314fb3cc8f12aef4a0dcd67ddc3677d5b54f/pkg/apis/tuned/v1/tuned_types.go\n\nThe PerformanceProfile API is defined here:\nhttps://github.com/openshift/cluster-node-tuning-operator/tree/b41042d42d4ba5bb2e99960248cf1d6ae4935018/pkg/apis/performanceprofile/v2\n\nEach ConfigMap must have a single key named \"tuning\" whose value is the\nJSON or YAML of a serialized Tuned or PerformanceProfile.\nChanging this field will trigger a NodePool rollout.",
          "items": {
            "description": "LocalObjectReference contains enough information to let you locate the\nreferenced object inside the same namespace.",
            "properties": {
              "name": {
                "default": "",
                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                "type": "string"
              }
            },
            "type": "object",
            "x-kubernetes-map-type": "atomic"
          },
          "type": "array"
        }
      },
      "required": [
        "clusterName",
        "management",
        "platform",
        "release"
      ],
      "type": "object",
      "x-kubernetes-validations": [
        {
          "message": "Arch is required once set",
          "rule": "!has(oldSelf.arch) || has(self.arch)"
        },
        {
          "message": "Setting Arch to arm64 is only supported for AWS, Azure and Agent",
          "rule": "self.arch != 'arm64' || has(self.platform.aws) || has(self.platform.azure) || has(self.platform.agent)"
        },
        {
          "message": "Both replicas or autoScaling should not be set",
          "rule": "!has(self.replicas) || !has(self.autoScaling)"
        }
      ]
    },
    "status": {
      "description": "Status is the latest observed status of the NodePool.",
      "properties": {
        "conditions": {
          "description": "Conditions represents the latest available observations of the node pool's\ncurrent state.",
          "items": {
            "description": "We define our own condition type since metav1.Condition has validation\nfor Reason that might be broken by what we bubble up from CAPI.\nNodePoolCondition defines an observation of NodePool resource operational state.",
            "properties": {
              "lastTransitionTime": {
                "description": "Last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
                "format": "date-time",
                "type": "string"
              },
              "message": {
                "description": "A human readable message indicating details about the transition.\nThis field may be empty.",
                "type": "string"
              },
              "observedGeneration": {
                "format": "int64",
                "minimum": 0,
                "type": "integer"
              },
              "reason": {
                "description": "The reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may not be empty.",
                "type": "string"
              },
              "severity": {
                "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False.",
                "type": "string"
              },
              "status": {
                "description": "Status of the condition, one of True, False, Unknown.",
                "type": "string"
              },
              "type": {
                "description": "Type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
                "type": "string"
              }
            },
            "required": [
              "lastTransitionTime",
              "status",
              "type"
            ],
            "type": "object"
          },
          "type": "array"
        },
        "platform": {
          "description": "Platform hols the specific statuses",
          "properties": {
            "kubeVirt": {
              "description": "KubeVirt contains the KubeVirt platform statuses",
              "properties": {
                "cacheName": {
                  "description": "CacheName holds the name of the cache DataVolume, if exists",
                  "type": "string"
                },
                "credentials": {
                  "description": "Credentials shows the client credentials used when creating KubeVirt virtual machines.\nThis filed is only exists when the KubeVirt virtual machines are being placed\non a cluster separate from the one hosting the Hosted Control Plane components.\n\nThe default behavior when Credentials is not defined is for the KubeVirt VMs to be placed on\nthe same cluster and namespace as the Hosted Control Plane.",
                  "properties": {
                    "infraKubeConfigSecret": {
                      "description": "InfraKubeConfigSecret is a reference to a secret that contains the kubeconfig for the external infra cluster\nthat will be used to host the KubeVirt virtual machines for this cluster.",
                      "properties": {
                        "key": {
                          "type": "string"
                        },
                        "name": {
                          "type": "string"
                        }
                      },
                      "required": [
                        "key",
                        "name"
                      ],
                      "type": "object",
                      "x-kubernetes-validations": [
                        {
                          "message": "infraKubeConfigSecret is immutable",
                          "rule": "self == oldSelf"
                        }
                      ]
                    },
                    "infraNamespace": {
                      "description": "InfraNamespace defines the namespace on the external infra cluster that is used to host the KubeVirt\nvirtual machines. This namespace must already exist before creating the HostedCluster and the kubeconfig\nreferenced in the InfraKubeConfigSecret must have access to manage the required resources within this\nnamespace.",
                      "type": "string",
                      "x-kubernetes-validations": [
                        {
                          "message": "infraNamespace is immutable",
                          "rule": "self == oldSelf"
                        }
                      ]
                    }
                  },
                  "required": [
                    "infraKubeConfigSecret",
                    "infraNamespace"
                  ],
                  "type": "object"
                }
              },
              "type": "object"
            }
          },
          "type": "object"
        },
        "replicas": {
          "description": "Replicas is the latest observed number of nodes in the pool.",
          "format": "int32",
          "type": "integer"
        },
        "version": {
          "description": "Version is the semantic version of the latest applied release specified by\nthe NodePool.",
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "required": [
    "apiVersion",
    "kind"
  ],
  "type": "object",
  "x-kubernetes-group-version-kind": [
    {
      "group": "hypershift.openshift.io",
      "kind": "NodePool",
      "version": "v1beta1"
    }
  ]
}